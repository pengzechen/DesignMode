
## 招式： 
    编程语言、开发工具、开发技术、框架
## 内功：
    数据结构、算法、设计模式、重构、软件工程

## 四人组（Gang of Four）简称 Gof
Gof 将模式的概念引入软件工程领域、软件模式诞生。

## 软件设计模式种类
创建型、结构型、行为型
如何创建对象，如何实现类或对象的组合、类和对象怎样交互以及怎样分配职责。

## 面向对象设计原则
可维护性、可复用性。  高内聚、低耦合


### 1、单一职责原则：
类的指责单一、对外只提供一种功能、引起类变化的原因应该只有一个。
### 2、开闭原则：
类的改动是通过增加代码进行的，而不是修改源代码。
对拓展开放，对修改关闭
### 3、里氏代换：
抽象类 出现的地方都可以用他的 实现类 进行替换。
### 4、依赖倒转原则：
依赖于抽象（接口），不要依赖于具体的实现（类），针对接口编程。
### 5、接口隔离原则：
不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供
一种对外功能，不应该把所有的操作都封装到一个接口中去。
### 6、合成复用原则：
如果使用继承会导致父类的任何变换都可能影响到子类的行为。如果使用
对象组合就降低了这种依赖关系。对于继承和组合，优先使用组合。
### 7、蒂米特原则：
一个对象应该对其他对象尽可能少的了解，从而降低各个对象之间的耦合，
提高系统的可维护性

一、创建型模式（Creational Patterns）
用于隐藏对象创建的过程，提供更灵活的实例化方式。

模式	作用
Singleton（单例模式）	保证一个类只有一个实例，并提供全局访问点。
Factory Method（工厂方法）	定义一个用于创建对象的接口，让子类决定实例化哪一个类。
Abstract Factory（抽象工厂）	提供一个创建一系列相关或相互依赖对象的接口。
Builder（建造者模式）	将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
Prototype（原型模式）	通过复制已有实例来创建新对象，而不是通过构造函数。

二、结构型模式（Structural Patterns）
用于类或对象的组合，形成更大的结构。

模式	作用
Adapter（适配器模式）	将一个类的接口转换成客户期望的另一个接口。
Bridge（桥接模式）	将抽象部分与实现部分分离，使它们可以独立变化。
Composite（组合模式）	将对象组合成树形结构以表示“部分-整体”的层次结构。
Decorator（装饰器模式）	动态地为对象添加功能，而不影响其他对象。
Facade（外观模式）	提供一个统一的接口，用于访问子系统中的一组接口。
Flyweight（享元模式）	通过共享大量细粒度对象来减少内存使用。
Proxy（代理模式）	为其他对象提供一个代理以控制对其的访问。

三、行为型模式（Behavioral Patterns）
关注对象之间的通信与职责分配。

模式	作用
Observer（观察者模式）	一种对象状态变化通知多个依赖对象的机制。
Strategy（策略模式）	定义一系列算法，并使它们可以互换。
Command（命令模式）	将请求封装成对象，以便参数化客户端、队列或日志请求。
Chain of Responsibility（责任链模式）	让多个对象有机会处理请求，形成一条处理链。
Mediator（中介者模式）	用一个中介对象封装对象之间的交互。
State（状态模式）	允许对象在内部状态改变时改变其行为。
Template Method（模板方法）	定义一个操作中的算法骨架，具体步骤由子类实现。
Iterator（迭代器模式）	提供一种方法顺序访问集合对象的元素，而不暴露其内部表示。
Visitor（访问者模式）	将操作封装到访问者对象中，实现对结构中各元素的操作分离。
Interpreter（解释器模式）	给定语言，定义其文法表示并实现解释器。
Memento（备忘录模式）	在不破坏封装性的前提下，保存对象的状态以便恢复。
